import os, base64, json, uuid
from flask import Blueprint, jsonify, request, render_template, send_from_directory
from sqlalchemy import text
import boto3
from botocore.exceptions import ClientError
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from secrets import token_bytes
from app import db   # create_app에서 초기화한 db 객체 가져오기

# 환경 변수
REGION = os.getenv("AWS_REGION", "ap-northeast-2")
KMS_KEY_ID = os.getenv("KMS_KEY_ID", "alias/KEK")

crypto_bp = Blueprint("crypto", __name__)
kms = boto3.client("kms", region_name=REGION)


# --- DB 핑 ---
@crypto_bp.get("/api/dbping")
def dbping():
    with db.engine.connect() as conn:
        row = conn.execute(
            text("select current_database(), current_user, current_schemas(true), now()")
        ).fetchone()
        return {
            "db": row[0],
            "user": row[1],
            "search_path": row[2],
            "now": str(row[3])
        }, 200


# --- KMS 테스트 ---
@crypto_bp.get("/api/kms-test")
def kms_test():
    try:
        res = kms.generate_data_key(KeyId=KMS_KEY_ID, KeySpec="AES_256")
        ct_len = len(res.get("CiphertextBlob", b"") or b"")
        return jsonify({"ok": True, "ciphertext_blob_len": ct_len}), 200
    except ClientError as e:
        return jsonify({"ok": False, "error": str(e)}), 500


# --- 암호화 (파일 업로드 + 마스킹 + 토큰 발급) ---
@crypto_bp.post("/api/encrypt")
def encrypt():
    try:
        if "file" not in request.files:
            return jsonify({"ok": False, "error": "file_required"}), 400

        f = request.files["file"]
        raw = f.read()
        filename = f.filename or "upload.bin"
        token = str(uuid.uuid4())

        # --- 1) 마스킹 처리: 파일 전체를 '*'로 ---
        try:
            text_data = raw.decode("utf-8")
            masked_bytes = ("*" * len(text_data)).encode("utf-8")
        except Exception:
            masked_bytes = b"*" * len(raw)

        # --- 2) 마스킹 파일 저장 (원본파일명 + .mask.ext) ---
        name, ext = os.path.splitext(filename)
        if not name:
            name = "upload"
        masked_name = f"{name}.mask{ext or '.bin'}"

        masked_path = os.path.join("static", "masked")
        os.makedirs(masked_path, exist_ok=True)
        with open(os.path.join(masked_path, masked_name), "wb") as out:
            out.write(masked_bytes)

        # --- 3) KMS에서 DEK 발급 ---
        resp = kms.generate_data_key(KeyId=KMS_KEY_ID, KeySpec="AES_256")
        dek_plain = resp["Plaintext"]
        wdek = resp["CiphertextBlob"]

        # --- 4) AES-GCM 암호화 ---
        iv = token_bytes(12)
        aesgcm = AESGCM(dek_plain)
        ciphertext = aesgcm.encrypt(iv, raw, None)  # aad=None

        # --- 5) 토큰 + CryptoPackage DB 저장 ---
        sql = text("""
            INSERT INTO crypto_tokens (token, wdek, iv, ciphertext, tag, meta)
            VALUES (:token, :wdek, :iv, :ciphertext, :tag, CAST(:meta AS JSONB))
        """)
        db.session.execute(sql, {
            "token": token,
            "wdek": base64.b64encode(wdek).decode(),
            "iv": base64.b64encode(iv).decode(),
            "ciphertext": base64.b64encode(ciphertext).decode(),
            "tag": "",
            "meta": json.dumps({"filename": filename})
        })
        db.session.commit()

        return jsonify({
            "ok": True,
            "token": token,
            "masked_file_url": f"/static/masked/{masked_name}"
        }), 200

    except ClientError as e:
        db.session.rollback()
        return jsonify({
            "ok": False,
            "error": "kms_unavailable",
            "message": str(e)
        }), 500
    except Exception as e:
        db.session.rollback()
        return jsonify({
            "ok": False,
            "error": "encrypt_failed",
            "message": str(e)
        }), 500


# --- 복호화 (토큰 기반) ---
@crypto_bp.post("/api/decrypt")
def decrypt():
    try:
        body = request.get_json(force=True, silent=True) or {}
        token = body.get("token")
        if not token:
            return jsonify({"ok": False, "error": "missing 'token'"}), 400

        # 1) DB에서 패키지 조회
        row = db.session.execute(text("""
            SELECT wdek, iv, ciphertext, meta FROM crypto_tokens WHERE token = :token
        """), {"token": token}).fetchone()

        if not row:
            return jsonify({"ok": False, "error": "token_not_found"}), 404

        wdek = base64.b64decode(row[0])
        iv = base64.b64decode(row[1])
        ciphertext = base64.b64decode(row[2])
        meta = json.loads(row[3]) if row[3] else {}

        # 2) KMS 복호화
        resp = kms.decrypt(CiphertextBlob=wdek)
        dek_plain = resp["Plaintext"]

        # 3) AES-GCM 복호화
        aesgcm = AESGCM(dek_plain)
        plaintext = aesgcm.decrypt(iv, ciphertext, None)

        orig_name = meta.get("filename", "decrypted_file")

        return jsonify({
            "ok": True,
            "result": base64.b64encode(plaintext).decode(),
            "filename": orig_name
        }), 200

    except ClientError as e:
        return jsonify({
            "ok": False,
            "error": "kms_unavailable",
            "message": str(e)
        }), 500
    except Exception as e:
        return jsonify({
            "ok": False,
            "error": "decrypt_failed",
            "message": str(e)
        }), 500


# --- 업로드 페이지 (암호화/복호화 UI) ---
@crypto_bp.route("/upload")
def upload_page():
    return render_template("upload.html")


# --- 마스킹 파일 무조건 다운로드 ---
@crypto_bp.get("/static/masked/<path:fname>")
def download_masked(fname):
    return send_from_directory("static/masked", fname, as_attachment=True)

